These are all the queries I have ran in Supabase:

-- Create users table
CREATE TABLE users (
  id UUID REFERENCES auth.users NOT NULL PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Create pins table
CREATE TABLE pins (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES users(id) NOT NULL,
  latitude DECIMAL NOT NULL,
  longitude DECIMAL NOT NULL,
  description TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  CONSTRAINT description_length CHECK (char_length(description) >= 50 AND char_length(description) <= 500)
);

-- Create pin_images table
CREATE TABLE pin_images (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  pin_id UUID REFERENCES pins(id) ON DELETE CASCADE NOT NULL,
  image_url TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE pins ENABLE ROW LEVEL SECURITY;
ALTER TABLE pin_images ENABLE ROW LEVEL SECURITY;

-- Users can read all profiles, but only update their own
CREATE POLICY "Users can view all profiles" ON users FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON users FOR UPDATE USING (auth.uid() = id);

-- Anyone can read pins, but only authenticated users can create
CREATE POLICY "Anyone can view pins" ON pins FOR SELECT USING (true);
CREATE POLICY "Users can create pins" ON pins FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own pins" ON pins FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own pins" ON pins FOR DELETE USING (auth.uid() = user_id);

-- Same for pin images
CREATE POLICY "Anyone can view pin images" ON pin_images FOR SELECT USING (true);
CREATE POLICY "Users can create images for their pins" ON pin_images FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM pins WHERE pins.id = pin_id AND pins.user_id = auth.uid())
);

-- Add policy to allow users to insert their own profile
CREATE POLICY "Users can insert own profile" ON users 
FOR INSERT WITH CHECK (auth.uid() = id);

-- Add new columns to existing users table
ALTER TABLE users 
ADD COLUMN display_name TEXT,
ADD COLUMN purdue_email TEXT UNIQUE,
ADD COLUMN graduation_year INTEGER,
ADD COLUMN is_verified BOOLEAN DEFAULT false;

-- Add constraint for Purdue emails
ALTER TABLE users 
ADD CONSTRAINT purdue_email_check CHECK (purdue_email LIKE '%@purdue.edu');

-- Rename the table
ALTER TABLE pins RENAME TO events;

-- Add new columns
ALTER TABLE events 
ADD COLUMN title TEXT,
ADD COLUMN start_time TIMESTAMP WITH TIME ZONE,
ADD COLUMN end_time TIMESTAMP WITH TIME ZONE,
ADD COLUMN contact_info TEXT,
ADD COLUMN category TEXT DEFAULT 'Other',
ADD COLUMN image_url TEXT,
ADD COLUMN view_count INTEGER DEFAULT 0;

-- Update constraints
ALTER TABLE events DROP CONSTRAINT IF EXISTS description_length;
ALTER TABLE events ADD CONSTRAINT title_length CHECK (char_length(title) >= 5 AND char_length(title) <= 100);
ALTER TABLE events ADD CONSTRAINT description_length CHECK (char_length(description) >= 20 AND char_length(description) <= 500);

ALTER TABLE events 
ADD CONSTRAINT valid_time_range CHECK (end_time > start_time),
ADD CONSTRAINT future_event CHECK (start_time > now()),
ADD CONSTRAINT valid_category CHECK (category IN ('Food', 'Study', 'Club', 'Social', 'Academic', 'Other'));

-- Delete events outside Purdue campus
DELETE FROM events WHERE NOT (
  latitude BETWEEN 40.4180 AND 40.4360 AND 
  longitude BETWEEN -86.9340 AND -86.9050
);

-- Now add the constraint
ALTER TABLE events ADD CONSTRAINT purdue_campus_bounds 
CHECK (
  latitude BETWEEN 40.4180 AND 40.4360 AND 
  longitude BETWEEN -86.9340 AND -86.9050
);

-- Drop existing policies on events table
DROP POLICY IF EXISTS "Enable read access for all users" ON events;
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON events;
DROP POLICY IF EXISTS "Enable update for users based on user_id" ON events;
DROP POLICY IF EXISTS "Enable delete for users based on user_id" ON events;

-- Create new policies
CREATE POLICY "Anyone can view active events" ON events
  FOR SELECT USING (end_time > now());

CREATE POLICY "Purdue users can create events" ON events
  FOR INSERT WITH CHECK (
    auth.uid() = user_id AND 
    EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND purdue_email IS NOT NULL)
  );

CREATE POLICY "Users can manage own events" ON events
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own events" ON events
  FOR DELETE USING (auth.uid() = user_id);

-- Create function to delete expired events
CREATE OR REPLACE FUNCTION cleanup_expired_events()
RETURNS void AS $$
BEGIN
  DELETE FROM events WHERE end_time < now() - INTERVAL '1 hour';
END;
$$ LANGUAGE plpgsql;

-- Enable cron extension for scheduled cleanup
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Schedule cleanup every hour
SELECT cron.schedule('cleanup-expired-events', '0 * * * *', 'SELECT cleanup_expired_events();');

-- User interaction tracking for recommendations
CREATE TABLE user_event_interactions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES users(id) NOT NULL,
  event_id UUID REFERENCES events(id) ON DELETE CASCADE NOT NULL,
  interaction_type TEXT NOT NULL, -- 'view', 'click'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  UNIQUE(user_id, event_id, interaction_type)
);

-- Enable RLS and policies
ALTER TABLE user_event_interactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own interactions" ON user_event_interactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create own interactions" ON user_event_interactions FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Performance indexes
CREATE INDEX idx_user_interactions_user_id ON user_event_interactions(user_id);
CREATE INDEX idx_events_view_count ON events(view_count DESC);
CREATE INDEX idx_events_created_at ON events(created_at DESC);

-- Function to increment event view count
CREATE OR REPLACE FUNCTION increment_view_count(event_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE events
  SET view_count = view_count + 1
  WHERE id = event_id;
END;
$$ LANGUAGE plpgsql;

-- Add RLS policy to allow the function to be called
CREATE POLICY "Allow increment_view_count function" ON events
  FOR UPDATE USING (
    (SELECT true)  -- Allow the function to update any event's view count
  ) WITH CHECK (
    (SELECT true)
  );

  -- Function to update user profile
CREATE OR REPLACE FUNCTION update_user_profile(
  p_display_name TEXT,
  p_graduation_year INTEGER
)
RETURNS SETOF users AS $$
BEGIN
  RETURN QUERY
  UPDATE users
  SET 
    display_name = COALESCE(p_display_name, display_name),
    graduation_year = COALESCE(p_graduation_year, graduation_year),
    updated_at = now()
  WHERE id = auth.uid()
  RETURNING *;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to delete user account and all associated data
CREATE OR REPLACE FUNCTION delete_user_account()
RETURNS void AS $$
BEGIN
  -- Delete all user's events
  DELETE FROM events WHERE user_id = auth.uid();
  
  -- Delete all user's interactions
  DELETE FROM user_event_interactions WHERE user_id = auth.uid();
  
  -- Delete the user profile
  DELETE FROM users WHERE id = auth.uid();
  
  -- Delete the user from auth.users
  DELETE FROM auth.users WHERE id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update RLS policies
CREATE POLICY "Users can delete their own account" ON users
  FOR DELETE USING (auth.uid() = id);

  -- Add constraints for graduation year and display name length
ALTER TABLE users 
DROP CONSTRAINT IF EXISTS valid_graduation_year;

ALTER TABLE users 
ADD CONSTRAINT valid_graduation_year 
CHECK (
  graduation_year >= EXTRACT(YEAR FROM CURRENT_DATE) AND 
  graduation_year <= EXTRACT(YEAR FROM CURRENT_DATE) + 10
);

-- Add constraint for display name length (let's set it to 50 characters)
ALTER TABLE users 
DROP CONSTRAINT IF EXISTS display_name_length;

ALTER TABLE users 
ADD CONSTRAINT display_name_length 
CHECK (char_length(display_name) >= 2 AND char_length(display_name) <= 50);

-- Create RPC function to handle user interactions with proper auth context
CREATE OR REPLACE FUNCTION upsert_user_interaction(
  p_user_id UUID,
  p_event_id UUID,
  p_interaction_type TEXT
)
RETURNS void AS $$
BEGIN
  -- Insert or update the interaction
  INSERT INTO user_event_interactions (user_id, event_id, interaction_type)
  VALUES (p_user_id, p_event_id, p_interaction_type)
  ON CONFLICT (user_id, event_id, interaction_type) 
  DO UPDATE SET created_at = now();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION upsert_user_interaction(UUID, UUID, TEXT) TO authenticated;